#ifndef TARGET_CORE_QODX_LIB_H
#define TARGET_CORE_QODX_LIB_H


#include <linux/types.h>
#include <linux/kernel.h>
#include <asm/unaligned.h>
#include <scsi/scsi.h>

#include "target_core_qlib.h"
#include "target_core_qodx_scsi.h"

/**/
#define SPC_SENSE_KEY_OFFSET			2
#define SPC_ADD_SENSE_LEN_OFFSET		7
#define SPC_DESC_TYPE_OFFSET			8
#define SPC_ADDITIONAL_DESC_LEN_OFFSET		9
#define SPC_VALIDITY_OFFSET			10
#define SPC_ASC_KEY_OFFSET			12
#define SPC_ASCQ_KEY_OFFSET			13

/**/
#define MAX_SG_IO_DATA_COUNT	8
struct sg_io_data {
	struct scatterlist	*data_sg;
	u64			data_len;
	u32			data_sg_nents;
};

struct wut_io_data {
	struct tpc_cmd_data	*tc_p;
	struct tpc_token_data	*s_token;
	struct tpc_token_data	*d_token;
	struct workqueue_struct *odx_rwio_wq;
	struct qnap_io_ops	*io_ops;
	u64			nr_bytes;        /* nr bytes to work */
	u64			s_rod_off_bytes; /* offset bytes to source rod data */
	sector_t		dest_lba;
	u32			dest_bs_order;
	RC			rc;
	struct sg_io_data	sg_io[MAX_SG_IO_DATA_COUNT];
} __attribute__ ((packed));

struct odx_io_cb_data {
	atomic_t		io_count;
	atomic_t		io_err_count;
	struct completion	*wait;
	int			nospc_err;
} __attribute__ ((packed));

/* used by wq */
struct wut_io_work_data {
	struct list_head	node;
	struct wut_io_data 	*io_data;
	struct odx_io_cb_data	*cb_data;
	struct work_struct	wut_io_work;
	sector_t		start_lba;
	u64			nr_bytes;
	int			sg_idx;
	bool			is_write;
	bool			transfer_done;
} __attribute__ ((packed));

struct helper_misc_data {
	void	*se_dev;
	void	*se_lun;
};

#define MD5_SIGNATURE_SIZE	16	/* 16 bytes in a MD5 message digest */
#define ODX_INVALID_OP		0x0
#define ODX_CP_OP		0x1
#define ODX_MONITOR_OP		0x2

/* OBJ TOKEN STATUS */
typedef enum{
	O_TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE  = 0, /* intial value */
	O_TOKEN_ALLOCATED_BUT_NOT_ALIVE  ,   /* token was allocated but not record in token_data */
	O_TOKEN_ALIVE                    ,   /* token was allocated and record in token_data */
	O_TOKEN_FREE_BY_PROC             ,   /* token will be free by other procedure */
	O_TOKEN_EXPIRED                  ,   /* token was expired */
	O_TOKEN_CANCELLED                ,   /* token was cancelled by copy manager */
	O_TOKEN_DELETED                  ,   /* token was deleted by ap client */
} TOKEN_STS;

/** 
 * @struct
 * @brief
 * @note
 */
#define CMD_ASKED_NOTHING		0
#define CMD_ASKED_BY_ABORT_TASK		1
#define CMD_ASKED_BY_ABORT_TASK_SET	2	/* TBD: we don't support this */
#define CMD_ASKED_BY_CLEAR_ACA		3	/* TBD: we don't support this */
#define CMD_ASKED_BY_CLEAR_TASK_SET	4	/* TBD: we don't support this */
#define CMD_ASKED_BY_LUN_RESET		5
#define CMD_ASKED_BY_TARGET_WARM_RESET	6	/* TBD: we don't support this */
#define CMD_ASKED_BY_TARGET_COLD_RESET	7	/* TBD: we don't support this */
#define CMD_ASKED_BY_RELEASE_CONN	8

/* The CUR_STATUS doesn't relate to copy operation status */
typedef enum{
	T_CMD_NOT_START         = 0 ,
	T_CMD_IS_STARTING_IN_FG ,
	T_CMD_IS_STARTING_IN_BG ,
	T_CMD_COMPLETED_W_ERR   ,
	T_CMD_COMPLETED_WO_ERR  ,
	T_CMD_WAS_ABORTED       ,
	MAX_T_CMD_STATUS        ,
}T_CMD_STATUS;

/* The OBJ_DATA_TYPE will indicate what kind of data will be kept by tpc obj */
typedef enum{
    O_DATA_TYPE_NONE        = 0,  /* no any data generated by 3rd-party copy command */
    O_DATA_TYPE_ROD            ,  /* the rod (include rod token) generated by 3rd-party copy command */
    O_DATA_TYPE_HOLD_DATA      ,  /* the hold data generated by 3rd-party copy command */
}OBJ_DATA_TYPE;



/** 
 * @struct BLK_RANGE_OBJ
 * @brief
 * @note 
 *
 */
#define R_STATUS_NOT_USED           0
#define R_STATUS_TRANSFER_USED      1
#define R_STATUS_TRUNCATE_USED      2

struct blk_range_data {
	struct list_head    br_node;
	sector_t            lba;
	u32                 nr_blks;

	/* Please refer the R_STATUS_XXX */
	u32                 curr_status;
	u32                 next_status;
};


/* macro for T_CMD_STATUS */
#define T_CMD_IS_NOT_START(status)          ((status == T_CMD_NOT_START) ? 1 : 0)
#define T_CMD_IS_START_FG(status)           ((status == T_CMD_IS_STARTING_IN_FG) ? 1 : 0)
#define T_CMD_IS_START_BG(status)           ((status == T_CMD_IS_STARTING_IN_BG) ? 1 : 0)
#define T_CMD_WAS_COMPLETED_W_ERR(status)   ((status == T_CMD_COMPLETED_W_ERR) ? 1 : 0)
#define T_CMD_WAS_COMPLETED_WO_ERR(status)  ((status == T_CMD_COMPLETED_WO_ERR) ? 1 : 0)
#define T_CMD_WAS_ABORT(status)             ((status == T_CMD_WAS_ABORTED) ? 1 : 0)

/*****************************************
 * macro for TPC TOKEN STATUS 
 ******************************************/
#define TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE(t_status) \
	((t_status == O_TOKEN_NOT_ALLOCATED_AND_NOT_ALIVE) ? 1 : 0)

#define TOKEN_ALLOCATED_NOT_ALIVE(t_status) \
	((t_status == O_TOKEN_ALLOCATED_BUT_NOT_ALIVE) ? 1 : 0)

#define TOKEN_ALIVE(t_status)		((t_status == O_TOKEN_ALIVE) ? 1 : 0)

#define TOKEN_FREE_BY_PROC(t_status)	((t_status == O_TOKEN_FREE_BY_PROC) ? 1 : 0)
#define TOKEN_EXPIRED(t_status)		((t_status == O_TOKEN_EXPIRED) ? 1 : 0)
#define TOKEN_CANCELLED(t_status)	((t_status == O_TOKEN_CANCELLED) ? 1 : 0)
#define TOKEN_DELETED(t_status)		((t_status == O_TOKEN_DELETED) ? 1 : 0)


#define IS_TPC_SCSI_OP(cdb_byte0) \
	((cdb_byte0 == EXTENDED_COPY) || (cdb_byte0 == RECEIVE_COPY_RESULTS))

#define IS_TPC_SCSI_PT_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x10))
#define IS_TPC_SCSI_WUT_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x11))
#define IS_TPC_SCSI_RRTI_OP(cdb_byte1) (((cdb_byte1 & 0x1f) == 0x07))

#define SAME_ID_OP_SAC(s_id, d_id, s_opsac, d_opsac) ((s_id == d_id) && (s_opsac == d_opsac))
#define GET_OP_SAC(cdb_byte0, cdb_byte1) ((cdb_byte0 << 8) | (cdb_byte1 & 0x1f))

#define DISCARD_TOKEN_LUN_RESET       0
#define DISCARD_TOKEN_I_T_NEXUS_LOSS  1

/**/
struct __reg_data {
	struct __dev_info	dev_info;
	/* where token comes from */
	u64			initiator_id_hi;
	u64			initiator_id_lo;
	/* where token goes to */
	u64			tpg_id_hi;
	u64			tpg_id_lo;
	/**/
	u64			cmd_id_hi;
	u64			cmd_id_lo;
	u32			list_id;
	u32			sac;
	int			cmd_type;
} __attribute__ ((packed));

struct tpc_tpg_data {
	struct rb_node		node;
	struct rb_root		cmd_root; /* curr working command */
	struct rb_root		token_root;
	spinlock_t		token_root_lock;
	spinlock_t		cmd_root_lock;
	atomic_t		ref_count;
	u64			id_hi;
	u64			id_lo;
	struct work_struct 	del_work;
};

struct tpc_cmd_data {
	struct rb_node		node;
	struct tpc_tpg_data	*tpg_p;
	struct list_head	del_node;
	struct __reg_data	reg_data;
	spinlock_t		cmd_asked_act_lock;
	spinlock_t		status_lock;
	spinlock_t		transfer_count_lock;
	atomic_t		ref_count;
	atomic_t		cmd_asked;
	atomic_t		cmd_status;

	/* FIXED ME !!
	 * the unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			transfer_count;
	u16			segs_processed;
	u16			op_counter;
	u8			sense_data[ROD_SENSE_DATA_LEN];
};

struct tpc_token_data {
	struct rb_node		node;
	struct tpc_tpg_data	*tpg_p;
	void			*se_dev; /* for fast block clone, it is DEPRECATED */
	struct list_head	del_node;
	struct __reg_data	reg_data;
	struct timer_list	timer;
	struct list_head	br_list;
	spinlock_t		br_list_lock;
	spinlock_t		transfer_count_lock;
	atomic_t		status;
	atomic_t		ref_count;
	void			*token;
	unsigned long		create_time;
	u32			token_timeout;
	bool			next_delete;
	/* --------------------------------------------------------
	 * --- Basic information for copy-operation data record ---
	 * --------------------------------------------------------
	 */

	/* The unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			transfer_count;
	u16			segs_processed;
	u16			op_counter;
	u16			cp_op_status;

	/* Status about the tpc cmd that originated copy operation. This will be 
	 * set to scsi status code. Please refer the SAM_STAT_XXXX in
	 * include\scsi\scsi.h
	*/
	u16			completion_status;
	u8			sense_data[ROD_SENSE_DATA_LEN];
};

#define MAX_ODX_WR_DATA_LEN	(1 << 20)
struct odx_work_request {
	u8 			*cdb;
	void			*buff;
	void			*se_dev; /* for fast block clone, it is DEPRECATED */
	struct tpc_tpg_data	*tpg_p;
	struct tpc_cmd_data	*tc_p;
	struct workqueue_struct *odx_rwio_wq;
	struct qnap_io_ops	*io_ops;
	/* registered data we want to touch */
	struct __reg_data	reg_data;
	struct sg_io_data	sg_io[MAX_SG_IO_DATA_COUNT];

	/* used to report final transfer count to struct se_cmd */
	u64			transfer_counts;	/* sector-based */
	RC			rc;
} __attribute__ ((packed));


/** 
 * @struct
 * @brief
 */
struct rod_type_table {
	u32     rod_type;
	bool    end_table;

	/*
	 * TokenOut - 1 : Indicate the copy manager supports the generation and
	 *                returning of ROD tokens that have ROD type indicated by 
	 *                ROD_TYPE filed by one or more commands that the copy 
	 *                manager processes
	 *
	 * TokenOut - 0 : Indicate the copy manager does NOT supports the generation
	 *                and returning of ROD tokens that have ROD type indicated by 
	 *                ROD_TYPE filed
	 */

	u32     token_out;

	/*
	 * TokenIn - 1 : Indicate the copy manager supports the receipt of ROD tokens
	 *               that have ROD type indicated by ROD_TYPE filed by one or more
	 *               commands that the copy manager processes
	 *
	 * TokenIn - 0 : Indicate the copy manager does NOT supports the receipt of
	 *               ROD tokens that have ROD type indicated by ROD_TYPE filed
	 */

	u32     token_in;
	/*
	 * EcpyInt - 1 : Support the ROD type indicated by ROD_TYPE filed for internal
	 *               RODs in the EXTENDED COPY command
	 *
	 * EcpyInt - 0 : Does NOT Support the ROD type indicated by ROD_TYPE filed 
	 *               for internal RODs in the EXTENDED COPY command
	 */

	u32     ecpy_int_bit;
	u32     preference_indication;
};

static inline T_CMD_STATUS __qnap_odx_get_tc_data_status(
	struct tpc_cmd_data *tc_data
	)
{
	return (T_CMD_STATUS)atomic_read(&tc_data->cmd_status);
}

static inline void __qnap_odxlib_update_tc_data_status(
	struct tpc_cmd_data *tc_data,
	T_CMD_STATUS status
	)
{
	atomic_set(&tc_data->cmd_status, status);
}

static inline void __qnap_odxlib_update_token_status(
	struct tpc_token_data *token, 	
	TOKEN_STS status
	)
{
	atomic_set(&token->status, status);
}

static inline int __qnap_odxlib_cmpxchg_token_status(
	struct tpc_token_data *token, 	
	TOKEN_STS old_status,
	TOKEN_STS new_status
	)
{
	return atomic_cmpxchg(&token->status, old_status, new_status);
}

static inline void __qnap_odxlib_lock_update_tc_cmd_transfer_count(
	struct tpc_cmd_data *tc_cmd,
	sector_t nr_blks
	)
{
	spin_lock(&tc_cmd->transfer_count_lock);
	tc_cmd->transfer_count += nr_blks;
	spin_unlock(&tc_cmd->transfer_count_lock);
}

static inline sector_t __qnap_odxlib_lock_get_tc_cmd_transfer_count(
	struct tpc_cmd_data *tc_cmd
	)
{
	sector_t nr_blks = 0;

	spin_lock(&tc_cmd->transfer_count_lock);
	nr_blks = tc_cmd->transfer_count;
	spin_unlock(&tc_cmd->transfer_count_lock);
	return nr_blks;
}

static inline bool __qnap_odx_is_odx_opcode(
	u8 *cdb_byte
	)
{
	if (IS_TPC_SCSI_OP(cdb_byte[0])
	&& (IS_TPC_SCSI_PT_OP(cdb_byte[1]) 
		|| IS_TPC_SCSI_WUT_OP(cdb_byte[1])
		|| IS_TPC_SCSI_RRTI_OP(cdb_byte[1]))
	)
		return true;

	return false;
}

static inline int __qnap_odx_get_list_id_by_cdb(
	u8 *cdb_byte,
	u32 *list_id
	)
{
	if ((cdb_byte[0] == EXTENDED_COPY) 
	&& (IS_TPC_SCSI_PT_OP(cdb_byte[1]) || IS_TPC_SCSI_WUT_OP(cdb_byte[1]))
	)
	{
		*list_id = get_unaligned_be32(&cdb_byte[6]);
		return 0;
	}

	if ((cdb_byte[0] == RECEIVE_COPY_RESULTS) 
	&& (IS_TPC_SCSI_RRTI_OP(cdb_byte[1]))
	)
	{
		*list_id = get_unaligned_be32(&cdb_byte[2]);
		return 0;
	}

	return -EINVAL;
}


static inline int __odx_is_token_deleted(
	TOKEN_STS token_status
	)
{
	if (TOKEN_DELETED(token_status)
	|| TOKEN_FREE_BY_PROC(token_status)
	)
		return 0;
	return -EINVAL;
}

static inline int __qnap_odxlib_is_token_invalid(
	struct tpc_token_data *token,
	RC *rc
	)
{
	int ret = -ENODEV, status;
	*rc = RC_GOOD;

	status = atomic_read(&token->status);

	if (TOKEN_CANCELLED(status))
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_CANCELLED;
	else if (TOKEN_EXPIRED(status))
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_EXPIRED;
	else if (__odx_is_token_deleted(status) == 0)
		*rc = RC_INVALID_TOKEN_OP_AND_TOKEN_DELETED;
	else
		ret = 0;

	return ret;
}

static inline bool __qnap_odxlib_cmd_was_asked_drop(
	struct tpc_cmd_data *tc_cmd
	)
{
	bool drop = false;

	switch(atomic_read(&tc_cmd->cmd_asked)) {
	case CMD_ASKED_BY_ABORT_TASK:
	case CMD_ASKED_BY_ABORT_TASK_SET:
	case CMD_ASKED_BY_CLEAR_ACA:
	case CMD_ASKED_BY_CLEAR_TASK_SET:
	case CMD_ASKED_BY_LUN_RESET:
	case CMD_ASKED_BY_TARGET_WARM_RESET:
	case CMD_ASKED_BY_TARGET_COLD_RESET:
	case CMD_ASKED_BY_RELEASE_CONN:
		drop = true;
		break;
	default:
		break;
	}

	return drop;
}

/* other odx helper functions */
int qnap_odxlib_check_valid_supported_rod_type(u32 rod_type);

int qnap_odxlib_check_max_lba_in_desc_list(struct blk_dev_range_desc *s, 
	sector_t max_lba, u16 counts);

int qnap_odxlib_check_overlap_lba_in_desc_list(struct blk_dev_range_desc *s,
	u16 counts);

int qnap_odxlib_check_same_lba_in_desc_list(struct blk_dev_range_desc *s,
	u16 counts);

int qnap_odxlib_is_duplicated_token_then_delete(
	struct tpc_tpg_data * tpg_p, 
	u64 cmd_id_hi, 
	u64 cmd_id_lo, 
	u64 initiator_id_hi, 
	u64 initiator_id_lo
	);

struct tpc_token_data *qnap_odxlib_token_data_alloc(
	struct odx_work_request *odx_wr,
	struct __reg_data *data
	);

void qnap_odxlib_token_data_free(struct tpc_token_data *p);

void qnap_odxlib_build_512b_token_data(struct odx_work_request *odx_wr,
	struct tpc_token_data *token);

void qnap_odxlib_set_obj_op_counter(struct tpc_token_data *token);
int qnap_odxlib_set_obj_completion_status(struct tpc_token_data *token);
void qnap_odxlib_start_token_timer(struct tpc_token_data *token, u32 timeout);
struct blk_range_data *qnap_odxlib_alloc_br(void);
void qnap_odxlib_free_br_lists(struct list_head *data_list);
void qnap_odxlib_free_token_lists(struct list_head *data_list);

int qnap_odxlib_wut_get_src_tpg_p_and_token_p(
	struct rod_token_512b *s_token512b_p, 
	struct tpc_tpg_data **s_tpg_p, 
	struct tpc_token_data **s_token_p, 
	struct tpc_token_data *d_token_p, 
	RC * rc
	);

int qnap_odxlib_wut_check_rod_off_before_wut_io(
	struct tpc_token_data *s_token_p,
	struct tpc_token_data *d_token_p, 
	sector_t src_nr_blks,
	sector_t dest_nr_blks,
	u64 off_to_rod,
	RC *rc
	);

void qnap_odxlib_build_token_sense_data(
	struct tpc_token_data *token,
	RC rc,
	u8 asc,
	u8 ascq
	);

sector_t qnap_odxlib_lock_get_nr_blks_by_s_token(struct tpc_token_data *s_token_p);

struct blk_range_data * qnap_odxlib_get_br_loc_by_rod_off(
	struct tpc_token_data *s_token,
	u64 off_bytes_to_rod, 
	sector_t *br_off
	);

int qnap_odxlib_wut_io(
	struct odx_work_request *odx_wr,
	struct tpc_token_data *s_token_p,
	struct tpc_token_data *d_token_p,
	bool run_wuzrt
	);

void qnap_odxlib_alloc_sg_lists(struct odx_work_request *req, bool use_wq);
void qnap_odxlib_free_sg_lists(struct odx_work_request *req);

extern struct kmem_cache *token512b_cache;
extern struct kmem_cache *odx_token_data_cache;
extern struct kmem_cache *odx_br_cache;
extern struct kmem_cache *odx_tpg_data_cache;
extern struct kmem_cache *odx_cmd_data_cache;

#endif

